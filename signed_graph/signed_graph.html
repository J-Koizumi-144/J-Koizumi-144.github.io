<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Signed Graph Visualizer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; margin: 0; }
    header { padding: 12px 16px; background: #111827; color: #fff; }
    main { display: grid; grid-template-columns: 380px 1fr; gap: 12px; padding: 12px; }
    @media (max-width: 1000px) { main { grid-template-columns: 1fr; } }
    .panel { background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; }
    textarea { width: 100%; height: 240px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button { cursor: pointer; border: 1px solid #cbd5e1; background: #fff; padding: 8px 12px; border-radius: 10px; }
    button:hover { background: #f1f5f9; }
    #error { color: #b91c1c; min-height: 1.2em; }
    .legend { display: flex; gap: 16px; align-items: center; }
    .badge { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:#eef2ff; border:1px solid #c7d2fe; }
    .badge .swatch { width:12px; height:12px; border-radius:999px; display:inline-block; }
    .note { color: #475569; font-size: 12px; }
    svg { width: 100%; height: 80vh; background: #ffffff; border: 1px solid #e5e7eb; border-radius: 12px; }
    .edge { stroke-width: 2; opacity: 0.85; }
    .node circle { r: 14px; fill: #111827; }
    .node text { fill: #fff; font-size: 12px; font-weight: 600; pointer-events: none; }
    .node { cursor: grab; }
    .node.dragging { cursor: grabbing; }
    .hr { height: 1px; background: #e5e7eb; margin: 10px 0; }
    .testlog { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; white-space: pre-wrap; background: #fff; border: 1px dashed #cbd5e1; padding: 8px; border-radius: 8px; }
    .ok { color: #065f46; }
    .ng { color: #b91c1c; }
  </style>
</head>
<body>
  <header>
    <div style="font-weight:700; font-size: 18px;">Signed Graph Visualizer</div>
  </header>
  <main>
    <section class="panel">
      <div style="margin-bottom:8px; font-weight:600;">Seidel matrix (diagonal 0, off‑diagonal ±1)</div>
      <textarea id="matrixInput" placeholder="One row per line. Commas/spaces/brackets are accepted."></textarea>
      <div class="controls" style="margin-top:8px;">
        <button id="exampleBtn">Load example</button>
        <button id="drawBtn">Render</button>
      </div>
      <div style="margin-top:10px; display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
        <div>
          <label><input type="radio" name="map" value="neg-red" checked> “−1 → Red”, “+1 → Blue”</label>
          <br />
          <label><input type="radio" name="map" value="neg-blue"> “−1 → Blue”, “+1 → Red”</label>
        </div>
        <div>
          <label><input type="checkbox" id="onlyRed"> Show only red edges</label>
        </div>
      </div>
      <div id="error"></div>
      <div class="note">✔ Click a vertex to flip the signs (±1) of all incident edges (Seidel switching). The display colors follow the current mapping.<br>✔ “Show only red edges” filters by <em>Red</em> as defined by the mapping above.</div>
      <div class="hr"></div>
    </section>
    <section class="panel">
      <svg id="viz" viewBox="0 0 1000 700"></svg>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const $ = (sel) => document.querySelector(sel);
    const viz = d3.select('#viz');
    let state = { nodes: [], edges: [], mapping: 'neg-red' };

    // --- Parser ---
    function parseMatrix(text) {
      const clean = text
        .replace(/\[/g, ' ')
        .replace(/\]/g, ' ')
        .replace(/\(/g, ' ')
        .replace(/\)/g, ' ')
        .trim();
      const rows = clean.split(/\n+/).map(line => line.trim()).filter(Boolean);
      if (rows.length === 0) throw new Error('Input is empty');
      const data = rows.map(r => r.split(/[\s,]+/).filter(Boolean).map(Number));
      const n = data.length;
      if (!data.every(row => row.length === n)) throw new Error('Matrix must be square');
      for (let i = 0; i < n; i++) {
        if (data[i][i] !== 0) throw new Error(`Diagonal entries must be 0 (i=${i+1})`);
        for (let j = i+1; j < n; j++) {
          const a = data[i][j], b = data[j][i];
          if (![-1,0,1].includes(a) || ![-1,0,1].includes(b)) throw new Error('Entries must be in {−1,0,1}');
          if (a !== b) throw new Error(`Matrix must be symmetric (i=${i+1}, j=${j+1})`);
          if (a === 0) throw new Error(`Off‑diagonal entries must be ±1 (i=${i+1}, j=${j+1})`);
        }
      }
      return data;
    }

    // --- Color mapping ---
    function colorFor(sign) {
      const negIsRed = state.mapping === 'neg-red';
      if (sign === -1) return negIsRed ? 'red' : 'royalblue';
      return negIsRed ? 'royalblue' : 'red';
    }

    // --- Circle layout ---
    function layoutCircle(n, w, h) {
      const R = Math.min(w, h) * 0.42;
      const cx = w / 2, cy = h / 2;
      const nodes = d3.range(n).map(i => {
        const theta = (2 * Math.PI * i) / n - Math.PI / 2;
        return { id: i, x: cx + R * Math.cos(theta), y: cy + R * Math.sin(theta) };
      });
      return nodes;
    }

    // --- Build graph ---
    function buildGraph(S, w, h) {
      const n = S.length;
      const nodes = layoutCircle(n, w, h);
      const edges = [];
      for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) {
          edges.push({ source: i, target: j, sign: S[i][j] });
        }
      }
      return { nodes, edges };
    }

    // --- Switching at a vertex (flip signs of incident edges) ---
    function switchAtVertex(v) {
      state.edges.forEach(e => {
        if (e.source === v || e.target === v) e.sign *= -1;
      });
      applyEdgeColorsAndVisibility();
    }

    // --- Render ---
    function render(S) {
      const vb = viz.attr('viewBox').split(/\s+/).map(Number);
      const w = vb[2], h = vb[3];
      state = { ...state, ...buildGraph(S, w, h) };

      viz.selectAll('*').remove();
      const g = viz.append('g');

      const edgeSel = g.append('g').attr('class','edges')
        .selectAll('line')
        .data(state.edges)
        .join('line')
        .attr('class','edge');

      function updateEdges() {
        edgeSel
          .attr('x1', d => state.nodes[d.source].x)
          .attr('y1', d => state.nodes[d.source].y)
          .attr('x2', d => state.nodes[d.target].x)
          .attr('y2', d => state.nodes[d.target].y);
      }

      const nodeSel = g.append('g').attr('class','nodes')
        .selectAll('g.node')
        .data(state.nodes)
        .join('g')
        .attr('class','node')
        .attr('transform', d => `translate(${d.x},${d.y})`)
        .call(d3.drag()
          .on('start', function (event, d) { d3.select(this).classed('dragging', true); })
          .on('drag', function (event, d) {
            d.x = event.x; d.y = event.y;
            d3.select(this).attr('transform', `translate(${d.x},${d.y})`);
            updateEdges();
          })
          .on('end', function () { d3.select(this).classed('dragging', false); })
        )
        .on('click', function(event, d) {
          if (event.defaultPrevented) return; // ignore click right after drag
          switchAtVertex(d.id);
        });

      nodeSel.append('circle');
      nodeSel.append('text').attr('dy', '0.35em').attr('text-anchor','middle').text(d => d.id + 1);

      updateEdges();
      applyEdgeColorsAndVisibility();

      // Zoom & pan
      viz.call(d3.zoom().scaleExtent([0.4, 3]).on('zoom', (event) => {
        g.attr('transform', event.transform);
      }));
    }

    function setError(msg) { $('#error').textContent = msg || ''; }

    function drawFromTextarea() {
      try {
        setError('');
        const S = parseMatrix($('#matrixInput').value);
        render(S);
      } catch (e) {
        setError(e.message);
      }
    }

    // --- UI events ---
    $('#drawBtn').addEventListener('click', drawFromTextarea);
    document.querySelectorAll('input[name="map"]').forEach(el => {
      el.addEventListener('change', (e) => {
        state.mapping = e.target.value;
        applyEdgeColorsAndVisibility();
      });
    });
    $('#onlyRed').addEventListener('change', applyEdgeColorsAndVisibility);

    $('#exampleBtn').addEventListener('click', () => {
      const example = `0  -1   1   1  -1\n-1   0  -1   1   1\n1  -1   0  -1   1\n1   1  -1   0  -1\n-1   1   1  -1   0`.trim();
      $('#matrixInput').value = example;
      drawFromTextarea();
    });

    $('#example2Btn').addEventListener('click', () => {
      // n=6 alternating signs example
      const n = 6;
      const S = Array.from({length:n}, (_, i) => Array.from({length:n}, (_, j) => (i===j?0:0)));
      for (let i=0;i<n;i++) {
        for (let j=i+1;j<n;j++) {
          const val = ((i + j) % 2 === 0) ? -1 : 1; // alternating
          S[i][j] = val; S[j][i] = val;
        }
      }
      const text = S.map(row => row.join(' ')).join('\n');
      $('#matrixInput').value = text;
      drawFromTextarea();
    });

    $('#randomBtn').addEventListener('click', () => {
      const n = Math.max(3, Math.min(50, (prompt('Enter size n (3–50 recommended)', '10')|0) || 10));
      const S = Array.from({length:n}, (_, i) => Array.from({length:n}, (_, j) => i===j?0:(i<j?(Math.random()<0.5?-1:1):0)));
      for (let i=0;i<n;i++) for (let j=i+1;j<n;j++) S[j][i]=S[i][j];
      const text = S.map(row => row.join(' ')).join('\n');
      $('#matrixInput').value = text;
      drawFromTextarea();
    });

    // Initial view: example
    $('#exampleBtn').click();

    // --- Apply red‑only visibility ---
    function applyEdgeColorsAndVisibility() {
      const onlyRed = document.querySelector('#onlyRed')?.checked;
      d3.selectAll('.edge')
        .attr('stroke', d => colorFor(d.sign))
        .attr('display', d => (onlyRed && colorFor(d.sign) !== 'red') ? 'none' : null);
    }

    // --- Quick tests ---
    function log(line, ok=true) {
      const el = document.createElement('div');
      el.className = ok ? 'ok' : 'ng';
      el.textContent = (ok ? '✓ ' : '✗ ') + line;
      $('#testLog').appendChild(el);
    }

    function clearLog() { $('#testLog').textContent = ''; }

    function runTests() {
      clearLog();
      try {
        // Test 1: Example parses and satisfies structure (square, diag 0, symmetric, ±1 off‑diag)
        const example = (
`0  -1   1   1  -1\n-1   0  -1   1   1\n 1  -1   0  -1   1\n 1   1  -1   0  -1\n-1   1   1  -1   0`);
        const A = parseMatrix(example);
        const n = A.length;
        let ok = true;
        for (let i=0;i<n;i++) {
          ok = ok && (A[i][i] === 0);
          for (let j=0;j<n;j++) {
            if (i!==j) ok = ok && (A[i][j] === 1 || A[i][j] === -1) && (A[i][j] === A[j][i]);
          }
        }
        log('Test1: Example matrix structural checks', ok);

        // Test 2: n=4, all edges −1, red‑only → 0 hidden edges when mapping neg‑red
        const B = Array.from({length:4}, (_, i) => Array.from({length:4}, (_, j) => (i===j?0:(i!==j?-1:0))));
        render(B);
        state.mapping = 'neg-red';
        $('#onlyRed').checked = true;
        applyEdgeColorsAndVisibility();
        const hidden = d3.selectAll('.edge').nodes().filter(e => e.getAttribute('display') === 'none').length;
        log('Test2: All −1 with red‑only → hidden 0', hidden === 0);

        // Test 3: Same B, mapping neg‑blue & red‑only → all hidden
        state.mapping = 'neg-blue';
        applyEdgeColorsAndVisibility();
        const total = d3.selectAll('.edge').nodes().length;
        const hidden2 = d3.selectAll('.edge').nodes().filter(e => e.getAttribute('display') === 'none').length;
        log('Test3: neg‑blue with red‑only → all hidden', hidden2 === total);

        // Test 4: Switch at vertex 0 (in n=4, all −1 → 3 incident edges become +1)
        switchAtVertex(0);
        const deg = 3; // degree in K4
        const plusOnIncident = state.edges.filter(e => (e.source===0||e.target===0) && e.sign===1).length;
        const minusElse = state.edges.filter(e => (e.source!==0&&e.target!==0) && e.sign===-1).length;
        log('Test4a: +1 on incident edges = 3', plusOnIncident === deg);
        log('Test4b: −1 on non‑incident edges = 3', minusElse === deg);
        state.mapping = 'neg-red';
        $('#onlyRed').checked = true;
        applyEdgeColorsAndVisibility();
        const hidden3 = d3.selectAll('.edge').nodes().filter(e => e.getAttribute('display') === 'none').length;
        log('Test4c: hidden edges with red‑only = 3', hidden3 === 3);

        // Test 5: Switch again at vertex 0 → back to all −1
        switchAtVertex(0);
        const allMinus = state.edges.every(e => e.sign === -1);
        log('Test5: Switching twice restores all −1', allMinus);

      } catch (err) {
        log('Exception while running tests: ' + (err && err.message ? err.message : err), false);
      }
    }

    $('#runTestsBtn').addEventListener('click', runTests);
  </script>
</body>
</html>
